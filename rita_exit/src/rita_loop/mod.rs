//! This is the primary actor loop for rita-exit, where periodic tasks are spawned and Actors are
//! tied together with message calls.
//!
//! In this loop the exit checks it's database for registered users and deploys the endpoint for
//! their exit tunnel the execution model for all of this is pretty whacky thanks to Actix quirks
//! we have the usual actors, these actors process Async events, but we have database queries by
//! Diesel that are sync so we create a special futures executor thread that runs only a single blocking
//! future. Since it's another thread
//!
//! Two threads are generated by this, one actual worker thread and a watchdog restarting thread that only
//! wakes up to restart the inner thread if anything goes wrong.

use crate::network_endpoints::*;

use crate::database::database_tools::get_database_connection_sync;
use crate::database::struct_tools::clients_to_ids;
use crate::database::{
    cleanup_exit_clients, enforce_exit_clients, setup_clients, validate_clients_region,
};
use crate::traffic_watcher::{TrafficWatcher, Watch};
use actix::Addr;
use actix::System;
use actix::SystemService;
use actix_async::System as AsyncSystem;
use actix_web_async::{web, App, HttpServer};
use althea_kernel_interface::ExitClient;
use althea_types::Identity;
use babel_monitor_legacy::open_babel_stream_legacy;
use babel_monitor_legacy::parse_routes_legacy;
use babel_monitor_legacy::start_connection_legacy;
use diesel::{query_dsl::RunQueryDsl, PgConnection};
use exit_db::models;
use futures01::future::Future;
use rita_common::debt_keeper::DebtAction;
use rita_common::utils::wait_timeout::wait_timeout;
use rita_common::utils::wait_timeout::WaitResult;
use std::collections::HashSet;
use std::thread;
use std::time::Duration;
use std::time::Instant;

use rita_common::KI;

// the speed in seconds for the exit loop
pub const EXIT_LOOP_SPEED: u64 = 5;
pub const EXIT_LOOP_SPEED_DURATION: Duration = Duration::from_secs(EXIT_LOOP_SPEED);
pub const EXIT_LOOP_TIMEOUT: Duration = Duration::from_secs(4);

/// Starts the rita exit billing thread, this thread deals with blocking db
/// calls and performs various tasks required for billing. The tasks interacting
/// with actix are the most troublesome because the actix system may restart
/// and crash this thread. To prevent that and other crashes we have a watchdog
/// thread which simply restarts the billing.
/// TODO remove futures on the non http endpoint / actix parts of this
/// TODO remove futures on the actix parts of this by moving to thread local state
pub fn start_rita_exit_loop() {
    setup_exit_wg_tunnel();
    // this is a reference to the non-async actix system
    let system = System::current();
    let mut last_restart = Instant::now();
    // outer thread is a watchdog, inner thread is the runner
    thread::spawn(move || {
        // this will always be an error, so it's really just a loop statement
        // with some fancy destructuring
        while let Err(e) = {
            let system_ref = system.clone();
            thread::spawn(move || {
                let tw = system_ref.registry().get();
                // a cache of what tunnels we had setup last round, used to prevent extra setup ops
                let mut wg_clients: HashSet<ExitClient> = HashSet::new();
                // a list of client debts from the last round, to prevent extra enforcement ops
                let mut debt_actions: HashSet<(Identity, DebtAction)> = HashSet::new();
                // if we have successfully setup the wg exit tunnel in the past, if false we have never
                // setup exit clients and should crash if we fail to do so, otherwise we are preventing
                // proper failover
                let mut successful_setup: bool = false;
                // wait until the system gets started
                while !tw.connected() {
                    trace!("Waiting for actors to start");
                }
                loop {
                    rita_exit_loop(
                        tw.clone(),
                        &mut wg_clients,
                        &mut debt_actions,
                        &mut successful_setup,
                        &system_ref,
                    )
                }
            })
            .join()
        } {
            error!("Exit loop thread panicked! Respawning {:?}", e);
            if Instant::now() - last_restart < Duration::from_secs(60) {
                error!("Restarting too quickly, leaving it to systemd!");
                system.stop_with_code(121)
            }
            last_restart = Instant::now();
        }
    });
}

fn rita_exit_loop(
    tw: Addr<TrafficWatcher>,
    wg_clients: &mut HashSet<ExitClient>,
    debt_actions: &mut HashSet<(Identity, DebtAction)>,
    successful_setup: &mut bool,
    system: &System,
) {
    let start = Instant::now();
    // opening a database connection takes at least several milliseconds, as the database server
    // may be across the country, so to save on back and forth we open on and reuse it as much
    // as possible
    match get_database_connection_sync() {
        Ok(conn) => {
            use exit_db::schema::clients::dsl::clients;
            let babel_port = settings::get_rita_exit().network.babel_port;
            info!(
                "Exit tick! got DB connection after {}ms",
                start.elapsed().as_millis(),
            );

            if let Ok(clients_list) = clients.load::<models::Client>(&conn) {
                trace!("got {:?} clients", clients_list);
                let ids = clients_to_ids(clients_list.clone());

                // watch and bill for traffic
                bill(babel_port, &tw, start, ids);

                info!("about to setup clients");
                // Create and update client tunnels
                match setup_clients(&clients_list, wg_clients) {
                    Ok(new_wg_clients) => {
                        *successful_setup = true;
                        *wg_clients = new_wg_clients;
                    }
                    Err(e) => error!("Setup clients failed with {:?}", e),
                }

                info!("about to cleanup clients");
                // find users that have not been active within the configured time period
                // and remove them from the db
                if let Err(e) = cleanup_exit_clients(&clients_list, &conn) {
                    error!("Exit client cleanup failed with {:?}", e);
                }

                // Make sure no one we are setting up is geoip unauthorized
                info!("about to check regions");
                check_regions(start, clients_list.clone(), &conn);

                info!("About to enforce exit clients");
                // handle enforcement on client tunnels by querying debt keeper
                // this consumes client list
                match enforce_exit_clients(clients_list, debt_actions) {
                    Ok(new_debt_actions) => *debt_actions = new_debt_actions,
                    Err(e) => warn!("Failed to enforce exit clients with {:?}", e,),
                }

                info!(
                    "Completed Rita exit loop in {}ms, all vars should be dropped",
                    start.elapsed().as_millis(),
                );
            }
        }
        Err(e) => {
            error!("Failed to get database connection with {}", e);
            if !*successful_setup {
                let db_uri = settings::get_rita_exit().db_uri;
                let message = format!(
                    "Failed to get database connection to {} on first setup loop, the exit can not operate without the ability to get the clients list from the database exiting",
                    db_uri
                );
                error!("{}", message);
                system.stop();
                panic!("{}", message);
            }
        }
    }
    // sleep until it has been 5 seconds from start, whenever that may be
    // if it has been more than 5 seconds from start, go right ahead
    if start.elapsed() < EXIT_LOOP_SPEED_DURATION {
        thread::sleep(EXIT_LOOP_SPEED_DURATION - start.elapsed());
    }
}

fn bill(babel_port: u16, tw: &Addr<TrafficWatcher>, start: Instant, ids: Vec<Identity>) {
    trace!("about to try opening babel stream");
    let res = wait_timeout(
        open_babel_stream_legacy(babel_port)
            .from_err()
            .and_then(|stream| {
                trace!("got babel stream");
                start_connection_legacy(stream).and_then(|stream| {
                    parse_routes_legacy(stream).and_then(|routes| {
                        trace!("Sending traffic watcher message?");
                        tw.do_send(Watch {
                            users: ids,
                            routes: routes.1,
                        });
                        Ok(())
                    })
                })
            }),
        EXIT_LOOP_TIMEOUT,
    );
    match res {
        WaitResult::Err(e) => warn!(
            "Failed to watch exit traffic with {:?} {}ms since start",
            e,
            start.elapsed().as_millis()
        ),
        WaitResult::Ok(_) => info!(
            "watch exit traffic completed successfully {}ms since loop start",
            start.elapsed().as_millis()
        ),
        WaitResult::TimedOut(_) => error!(
            "watch exit traffic timed out! {}ms since loop start",
            start.elapsed().as_millis()
        ),
    }
}

fn check_regions(start: Instant, clients_list: Vec<models::Client>, conn: &PgConnection) {
    let val = settings::get_rita_exit().allowed_countries.is_empty();
    if !val {
        let res = validate_clients_region(clients_list, conn);
        match res {
            Err(e) => warn!(
                "Failed to validate client region with {:?} {}ms since start",
                e,
                start.elapsed().as_millis()
            ),
            Ok(_) => info!(
                "validate client region completed successfully {}ms since loop start",
                start.elapsed().as_millis()
            ),
        }
    }
}

fn setup_exit_wg_tunnel() {
    if let Err(e) = KI.setup_wg_if_named("wg_exit") {
        warn!("exit setup returned {}", e)
    }
    KI.one_time_exit_setup(
        &settings::get_rita_exit()
            .exit_network
            .own_internal_ip
            .into(),
        settings::get_rita_exit().exit_network.netmask,
    )
    .expect("Failed to setup wg_exit!");
    KI.setup_nat(&settings::get_rita_exit().network.external_nic.unwrap())
        .unwrap();
}

pub fn check_rita_exit_actors() {
    assert!(crate::traffic_watcher::TrafficWatcher::from_registry().connected());
    assert!(crate::database::db_client::DbClient::from_registry().connected());
}

pub fn start_rita_exit_endpoints(workers: usize) {
    thread::spawn(move || {
        let runner = AsyncSystem::new();
        runner.block_on(async move {
            // Exit stuff, huge threadpool to offset Pgsql blocking
            let _res = HttpServer::new(|| {
                App::new()
                    .route("/secure_setup", web::post().to(secure_setup_request))
                    .route("/secure_status", web::post().to(secure_status_request))
                    .route("/exit_info", web::get().to(get_exit_info_http))
                    .route("/client_debt", web::post().to(get_client_debt))
            })
            .workers(workers)
            .bind(format!(
                "[::0]:{}",
                settings::get_rita_exit().exit_network.exit_hello_port
            ))
            .unwrap()
            .shutdown_timeout(0)
            .run()
            .await;
        });
    });
}
