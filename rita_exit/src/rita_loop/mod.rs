//! This is the primary actor loop for rita-exit, where periodic tasks are spawned and Actors are
//! tied together with message calls.
//!
//! In this loop the exit checks it's database for registered users and deploys the endpoint for
//! their exit tunnel the execution model for all of this is pretty whacky thanks to Actix quirks
//! we have the usual actors, these actors process Async events, but we have database queries by
//! Diesel that are sync so we create a special futures executor thread that runs only a single blocking
//! future. Since it's another thread
//!
//! Two threads are generated by this, one actual worker thread and a watchdog restarting thread that only
//! wakes up to restart the inner thread if anything goes wrong.

use crate::database::{
    enforce_exit_clients, setup_clients, validate_clients_region, ExitClientSetupStates,
};
use crate::network_endpoints::*;
use crate::traffic_watcher::watch_exit_traffic;
use actix::System as AsyncSystem;
use actix_web::{web, App, HttpServer};
use althea_kernel_interface::exit_server_tunnel::{one_time_exit_setup, setup_nat};
use althea_kernel_interface::setup_wg_if::create_blank_wg_interface;
use althea_kernel_interface::wg_iface_counter::WgUsage;
use althea_kernel_interface::ExitClient;
use althea_types::{Identity, SignedExitServerList, WgKey};
use babel_monitor::{open_babel_stream, parse_routes};
use clarity::Address;
use exit_trust_root::client_db::get_all_registered_clients;
use rita_common::debt_keeper::DebtAction;
use rita_common::rita_loop::get_web3_server;
use settings::exit::EXIT_LIST_PORT;
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;
use std::time::Instant;

// the speed in seconds for the exit loop
pub const EXIT_LOOP_SPEED: u64 = 5;
pub const EXIT_LOOP_SPEED_DURATION: Duration = Duration::from_secs(EXIT_LOOP_SPEED);
pub const EXIT_LOOP_TIMEOUT: Duration = Duration::from_secs(4);

/// Name of the legacy exit interface
pub const LEGACY_INTERFACE: &str = "wg_exit";
/// Name of the primary exit interface through which user traffic is decrypted to be forwarded out to the internet
pub const EXIT_INTERFACE: &str = "wg_exit_v2";

/// Cache of rita exit state to track across ticks
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct RitaExitCache {
    // a cache of what tunnels we had setup last round, used to prevent extra setup ops
    wg_clients: HashSet<ExitClient>,
    // a list of client debts from the last round, to prevent extra enforcement ops
    debt_actions: HashSet<(Identity, DebtAction)>,
    // if we have successfully setup the wg exit tunnel in the past, if false we have never
    // setup exit clients and should crash if we fail to do so, otherwise we are preventing
    // proper failover
    successful_setup: bool,
    // cache of b19 routers we have successful rules and routes for
    wg_exit_clients: HashSet<WgKey>,
    // cache of b20 routers we have successful rules and routes for
    wg_exit_v2_clients: HashSet<WgKey>,
    // A blacklist of clients that we fail geoip verification for. We tear down these routes
    geoip_blacklist: Vec<Identity>,
}

pub type ExitLock = Arc<RwLock<HashMap<WgKey, WgUsage>>>;

/// Starts the rita exit billing thread, this thread deals with blocking db
/// calls and performs various tasks required for billing. The tasks interacting
/// with actix are the most troublesome because the actix system may restart
/// and crash this thread. To prevent that and other crashes we have a watchdog
/// thread which simply restarts the internal thread.
pub fn start_rita_exit_loop(reg_clients_list: Vec<Identity>) {
    setup_exit_wg_tunnel();

    // the last usage of the wg tunnels, if an innner thread restarts this must be preserved to prevent
    // overbilling users
    let usage_history = Arc::new(RwLock::new(HashMap::new()));

    // this will always be an error, so it's really just a loop statement
    // with some fancy destructuring, blocking the caller thread as a watchdog
    while let Err(e) = {
        let reg_clients_list = reg_clients_list.clone();
        // ARC will simply clone the same reference
        let usage_history = usage_history.clone();
        thread::spawn(move || {
            // Internal exit cache that store state across multiple ticks
            let mut rita_exit_cache = RitaExitCache::default();
            let mut reg_clients_list = reg_clients_list.clone();
            let runner = AsyncSystem::new();
            runner.block_on(async move {
                loop {
                    reg_clients_list = update_client_list(reg_clients_list).await;

                    rita_exit_cache = rita_exit_loop(
                        reg_clients_list.clone(),
                        rita_exit_cache,
                        usage_history.clone(),
                    )
                    .await;
                }
            })
        })
        .join()
    } {
        error!("Exit loop thread panicked! Respawning {:?}", e);
    }
}

/// Updates the client list, if this is not successful the old client list is used
async fn update_client_list(reg_clients_list: Vec<Identity>) -> Vec<Identity> {
    let payment_settings = settings::get_rita_common().payment;
    let contract_address = settings::get_rita_exit()
        .exit_network
        .registered_users_contract_addr;
    let our_address = payment_settings.eth_address.expect("No address!");
    let full_node = get_web3_server();
    let web3 = web30::client::Web3::new(&full_node, Duration::from_secs(5));

    let get_clients_benchmark = Instant::now();
    match get_all_registered_clients(&web3, our_address, contract_address).await {
        Ok(list) => {
            info!(
                "Finished Rita get clients, got {:?} clients in {}ms",
                reg_clients_list.len(),
                get_clients_benchmark.elapsed().as_millis()
            );

            list
        }
        Err(e) => {
            error!(
                "Failed to get registered clients this this round, using last successful {:?}",
                e
            );
            reg_clients_list
        }
    }
}

async fn rita_exit_loop(
    reg_clients_list: Vec<Identity>,
    rita_exit_cache: RitaExitCache,
    usage_history: ExitLock,
) -> RitaExitCache {
    let mut rita_exit_cache = rita_exit_cache;
    let start = Instant::now();

    let rita_exit = settings::get_rita_exit();
    let babel_port = rita_exit.network.babel_port;

    let ids = reg_clients_list.clone();
    let start_bill_benchmark = Instant::now();
    // watch and bill for traffic
    bill(babel_port, start, ids, usage_history);
    info!(
        "Finished Rita billing in {}ms",
        start_bill_benchmark.elapsed().as_millis()
    );

    info!("About to setup clients");
    let start_setup_benchmark = Instant::now();
    // Create and update client tunnels
    match setup_clients(
        reg_clients_list.clone(),
        rita_exit_cache.geoip_blacklist.clone(),
        ExitClientSetupStates {
            old_clients: rita_exit_cache.wg_clients.clone(),
            wg_exit_clients: rita_exit_cache.wg_exit_clients.clone(),
            wg_exit_v2_clients: rita_exit_cache.wg_exit_v2_clients.clone(),
        },
    ) {
        Ok(client_states) => {
            rita_exit_cache.successful_setup = true;
            rita_exit_cache.wg_clients = client_states.old_clients;
            rita_exit_cache.wg_exit_clients = client_states.wg_exit_clients;
            rita_exit_cache.wg_exit_v2_clients = client_states.wg_exit_v2_clients;
        }
        Err(e) => error!("Setup clients failed with {:?}", e),
    }
    info!(
        "Finished Rita setting up clients in {}ms",
        start_setup_benchmark.elapsed().as_millis()
    );

    // Make sure no one we are setting up is geoip unauthorized
    let start_region_benchmark = Instant::now();
    info!("about to check regions");
    if let Some(list) = check_regions(start, reg_clients_list.clone()) {
        rita_exit_cache.geoip_blacklist = list;
    }
    info!(
        "Finished Rita checking region in {}ms",
        start_region_benchmark.elapsed().as_millis()
    );
    info!("About to enforce exit clients");
    // handle enforcement on client tunnels by querying debt keeper
    // this consumes client list
    let start_enforce_benchmark = Instant::now();
    match enforce_exit_clients(reg_clients_list, &rita_exit_cache.debt_actions.clone()) {
        Ok(new_debt_actions) => rita_exit_cache.debt_actions = new_debt_actions,
        Err(e) => warn!("Failed to enforce exit clients with {:?}", e,),
    }
    info!(
        "Finished Rita enforcement in {}ms ",
        start_enforce_benchmark.elapsed().as_millis()
    );
    info!(
        "Finished Rita exit loop in {}ms, all vars should be dropped",
        start.elapsed().as_millis(),
    );

    thread::sleep(EXIT_LOOP_SPEED_DURATION);
    rita_exit_cache
}

fn bill(babel_port: u16, start: Instant, ids: Vec<Identity>, usage_history: ExitLock) {
    trace!("about to try opening babel stream");

    match open_babel_stream(babel_port, EXIT_LOOP_TIMEOUT) {
        Ok(mut stream) => match parse_routes(&mut stream) {
            Ok(routes) => {
                trace!("Sending traffic watcher message?");
                if let Err(e) = watch_exit_traffic(usage_history, &routes, &ids) {
                    error!(
                        "Watch exit traffic failed with {}, in {} millis",
                        e,
                        start.elapsed().as_millis()
                    );
                } else {
                    info!(
                        "Watch exit traffic completed successfully in {} millis",
                        start.elapsed().as_millis()
                    );
                }
            }
            Err(e) => {
                error!(
                    "Watch exit traffic failed with: {} in {} millis",
                    e,
                    start.elapsed().as_millis()
                );
            }
        },
        Err(e) => {
            error!(
                "Watch exit traffic failed with: {} in {} millis",
                e,
                start.elapsed().as_millis()
            );
        }
    }
}

/// Run a region validation and return a list of blacklisted clients. This list is later used
/// in setup clients to teardown blacklisted client tunnels
fn check_regions(start: Instant, clients_list: Vec<Identity>) -> Option<Vec<Identity>> {
    let val = settings::get_rita_exit().allowed_countries.is_empty();
    if !val {
        let res = validate_clients_region(clients_list);
        match res {
            Err(e) => {
                warn!(
                    "Failed to validate client region with {:?} {}ms since start",
                    e,
                    start.elapsed().as_millis()
                );
                return None;
            }
            Ok(blacklist) => {
                info!(
                    "validate client region completed successfully {}ms since loop start",
                    start.elapsed().as_millis()
                );
                return Some(blacklist);
            }
        }
    }
    None
}

fn setup_exit_wg_tunnel() {
    // Setup legacy wg_exit
    if let Err(e) = create_blank_wg_interface(LEGACY_INTERFACE) {
        warn!("exit setup returned {}", e)
    }
    // Setup new wg_exit
    if let Err(e) = create_blank_wg_interface(EXIT_INTERFACE) {
        warn!("new exit setup returned {}", e)
    }

    let exit_settings = settings::get_rita_exit();

    let local_ip = exit_settings.exit_network.own_internal_ip.into();
    let netmask = exit_settings.exit_network.netmask;
    let mesh_ip = exit_settings
        .network
        .mesh_ip
        .expect("Expected a mesh ip for this exit");
    let enforcement_enabled = exit_settings.exit_network.enable_enforcement;
    let external_v6 = exit_settings
        .exit_network
        .subnet
        .map(|ipv6_subnet| (ipv6_subnet.ip(), ipv6_subnet.prefix()));

    // Setup legacy wg_exit
    one_time_exit_setup(None, None, mesh_ip, LEGACY_INTERFACE, enforcement_enabled)
        .expect("Failed to setup wg_exit!");

    // Setup wg_exit_v2. Local address added is same as that used by wg_exit
    one_time_exit_setup(
        Some((local_ip, netmask)),
        external_v6,
        mesh_ip,
        EXIT_INTERFACE,
        enforcement_enabled,
    )
    .expect("Failed to setup wg_exit_v2!");

    setup_nat(
        &settings::get_rita_exit().network.external_nic.unwrap(),
        LEGACY_INTERFACE,
        None,
    )
    .unwrap();
    setup_nat(
        &settings::get_rita_exit().network.external_nic.unwrap(),
        EXIT_INTERFACE,
        external_v6,
    )
    .unwrap();
}

pub fn start_rita_exit_endpoints(workers: usize) {
    thread::spawn(move || {
        let runner = AsyncSystem::new();
        runner.block_on(async move {
            // Exit stuff, huge threadpool to offset Pgsql blocking
            let _res = HttpServer::new(|| {
                App::new()
                    .route("/secure_setup", web::post().to(secure_setup_request))
                    .route("/secure_status", web::post().to(secure_status_request))
                    .route("/client_debt", web::post().to(get_client_debt))
                    .route("/time", web::get().to(get_exit_timestamp_http))
            })
            .workers(workers)
            .bind(format!(
                "[::0]:{}",
                settings::get_rita_exit().exit_network.exit_hello_port
            ))
            .unwrap()
            .shutdown_timeout(0)
            .run()
            .await;
        });
    });
}

/// the exit list gets its own server on hardcoded multihomed IP. Clients will always go to the nearest
/// instance of this IP due to the way babel handles multihoming. Due to race conditions we don't explicitly
/// bind to the IP for this listener, we instead bind to all available IPs. As we make tunnels kernel interface
/// will add the ip to each wg tunnel and then babel will handle the rest.
pub fn start_rita_exit_list_endpoint(workers: usize) {
    let exit_contract_data_cache: Arc<RwLock<HashMap<Address, SignedExitServerList>>> =
        Arc::new(RwLock::new(HashMap::new()));
    let web_data = web::Data::new(exit_contract_data_cache.clone());
    thread::spawn(move || {
        let runner = AsyncSystem::new();
        runner.block_on(async move {
            let _res = HttpServer::new(move || {
                App::new()
                    .route("/exit_list", web::post().to(get_exit_list))
                    .app_data(web_data.clone())
            })
            .workers(workers)
            .bind(format!("[::0]:{}", EXIT_LIST_PORT,))
            .unwrap()
            .shutdown_timeout(0)
            .run()
            .await;
        });
    });
}
