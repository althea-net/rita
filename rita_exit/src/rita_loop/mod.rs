//! This is the primary actor loop for rita-exit, where periodic tasks are spawned and Actors are
//! tied together with message calls.
//!
//! In this loop the exit checks it's database for registered users and deploys the endpoint for
//! their exit tunnel the execution model for all of this is pretty whacky thanks to Actix quirks
//! we have the usual actors, these actors process Async events, but we have database queries by
//! Diesel that are sync so we create a special futures executor thread that runs only a single blocking
//! future. Since it's another thread
//!
//! Two threads are generated by this, one actual worker thread and a watchdog restarting thread that only
//! wakes up to restart the inner thread if anything goes wrong.

use crate::network_endpoints::*;

use crate::database::{
    enforce_exit_clients, setup_clients, validate_clients_region, ExitClientSetupStates,
};
use crate::traffic_watcher::watch_exit_traffic;
use actix_async::System as AsyncSystem;
use actix_web_async::{web, App, HttpServer};
use althea_kernel_interface::wg_iface_counter::WgUsage;
use althea_kernel_interface::ExitClient;
use althea_types::{Identity, WgKey};
use babel_monitor::{open_babel_stream, parse_routes};

use rita_client_registration::client_db::get_all_regsitered_clients;
use rita_common::debt_keeper::DebtAction;
use rita_common::rita_loop::get_web3_server;
use web30::client::Web3;

use std::collections::{HashMap, HashSet};
use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;
use std::time::Instant;

use rita_common::KI;

// the speed in seconds for the exit loop
pub const EXIT_LOOP_SPEED: u64 = 5;
pub const EXIT_LOOP_SPEED_DURATION: Duration = Duration::from_secs(EXIT_LOOP_SPEED);
pub const EXIT_LOOP_TIMEOUT: Duration = Duration::from_secs(4);
/// Retry getting all clients for 5 mins before crashing
pub const GET_CLIENT_RETRY: Duration = Duration::from_secs(300);

/// Name of the legacy exit interface
pub const LEGACY_INTERFACE: &str = "wg_exit";
/// Name of the primary exit interface through which user traffic is decrypted to be forwarded out to the internet
pub const EXIT_INTERFACE: &str = "wg_exit_v2";

/// Cache of rita exit state to track across ticks
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct RitaExitCache {
    // a cache of what tunnels we had setup last round, used to prevent extra setup ops
    wg_clients: HashSet<ExitClient>,
    // a list of client debts from the last round, to prevent extra enforcement ops
    debt_actions: HashSet<(Identity, DebtAction)>,
    // if we have successfully setup the wg exit tunnel in the past, if false we have never
    // setup exit clients and should crash if we fail to do so, otherwise we are preventing
    // proper failover
    successful_setup: bool,
    // cache of b19 routers we have successful rules and routes for
    wg_exit_clients: HashSet<WgKey>,
    // cache of b20 routers we have successful rules and routes for
    wg_exit_v2_clients: HashSet<WgKey>,
    // A blacklist of clients that we fail geoip verification for. We tear down these routes
    geoip_blacklist: Vec<Identity>,
}

pub type ExitLock = Arc<RwLock<HashMap<WgKey, WgUsage>>>;

/// Starts the rita exit billing thread, this thread deals with blocking db
/// calls and performs various tasks required for billing. The tasks interacting
/// with actix are the most troublesome because the actix system may restart
/// and crash this thread. To prevent that and other crashes we have a watchdog
/// thread which simply restarts the billing.
pub fn start_rita_exit_loop() {
    setup_exit_wg_tunnel();
    let mut last_restart = Instant::now();

    // the last usage of the wg tunnels, if an innner thread restarts this must be preserved to prevent
    // overbilling users
    let usage_history = Arc::new(RwLock::new(HashMap::new()));

    // outer thread is a watchdog, inner thread is the runner
    thread::spawn(move || {
        // this will always be an error, so it's really just a loop statement
        // with some fancy destructuring
        while let Err(e) = {
            // ARC will simply clone the same reference
            let usage_history = usage_history.clone();
            thread::spawn(move || {
                // Internal exit cache that store state across multiple ticks
                let mut rita_exit_cache = RitaExitCache::default();
                let runner = AsyncSystem::new();
                runner.block_on(async move {
                    loop {
                        rita_exit_cache =
                            rita_exit_loop(rita_exit_cache, usage_history.clone()).await;
                    }
                })
            })
            .join()
        } {
            error!("Exit loop thread panicked! Respawning {:?}", e);
            if Instant::now() - last_restart < Duration::from_secs(60) {
                error!("Restarting too quickly, leaving it to systemd!");
                let sys = AsyncSystem::current();
                sys.stop_with_code(121);
            }
            last_restart = Instant::now();
        }
    });
}

async fn rita_exit_loop(rita_exit_cache: RitaExitCache, usage_history: ExitLock) -> RitaExitCache {
    let mut rita_exit_cache = rita_exit_cache;
    let start = Instant::now();

    let rita_exit = settings::get_rita_exit();
    let babel_port = rita_exit.network.babel_port;
    let contact = Web3::new(&get_web3_server(), CLIENT_STATUS_TIMEOUT);
    let our_addr = rita_exit
        .payment
        .eth_private_key
        .expect("Why do we not have a private key?")
        .to_address();
    let contract_addr = rita_exit.exit_network.registered_users_contract_addr;

    let get_clients_benchmark = Instant::now();

    // We retry getting users for 5 mins before we crash. Getting registered users is core functionality
    let reg_clients_list;
    let retry_start = Instant::now();
    loop {
        match get_all_regsitered_clients(&contact, our_addr, contract_addr).await {
            Ok(a) => {
                reg_clients_list = a;
                break;
            }
            Err(e) => {
                // Getting all clients is core functionality, we panic if fails
                let message = format!(
                "Failed to get all registered users with {}. Web3 url: {}, contract_addr: {}. This is required for exit to funciton correctly",
                e,
                get_web3_server(),
                contract_addr
            );
                error!("{}", message);
                thread::sleep(Duration::from_secs(10));
                if Instant::now() - retry_start > GET_CLIENT_RETRY {
                    let sys = AsyncSystem::current();
                    sys.stop();
                    panic!("{}", message);
                }
            }
        };
    }

    info!(
        "Finished Rita get clients, got {:?} clients in {}ms",
        reg_clients_list.len(),
        get_clients_benchmark.elapsed().as_millis()
    );

    let ids = reg_clients_list.clone();
    let start_bill_benchmark = Instant::now();
    // watch and bill for traffic
    bill(babel_port, start, ids, usage_history);
    info!(
        "Finished Rita billing in {}ms",
        start_bill_benchmark.elapsed().as_millis()
    );

    info!("About to setup clients");
    let start_setup_benchmark = Instant::now();
    // Create and update client tunnels
    match setup_clients(
        reg_clients_list.clone(),
        rita_exit_cache.geoip_blacklist.clone(),
        ExitClientSetupStates {
            old_clients: rita_exit_cache.wg_clients.clone(),
            wg_exit_clients: rita_exit_cache.wg_exit_clients.clone(),
            wg_exit_v2_clients: rita_exit_cache.wg_exit_v2_clients.clone(),
        },
    ) {
        Ok(client_states) => {
            rita_exit_cache.successful_setup = true;
            rita_exit_cache.wg_clients = client_states.old_clients;
            rita_exit_cache.wg_exit_clients = client_states.wg_exit_clients;
            rita_exit_cache.wg_exit_v2_clients = client_states.wg_exit_v2_clients;
        }
        Err(e) => error!("Setup clients failed with {:?}", e),
    }
    info!(
        "Finished Rita setting up clients in {}ms",
        start_setup_benchmark.elapsed().as_millis()
    );

    // Make sure no one we are setting up is geoip unauthorized
    let start_region_benchmark = Instant::now();
    info!("about to check regions");
    if let Some(list) = check_regions(start, reg_clients_list.clone()) {
        rita_exit_cache.geoip_blacklist = list;
    }
    info!(
        "Finished Rita checking region in {}ms",
        start_region_benchmark.elapsed().as_millis()
    );
    info!("About to enforce exit clients");
    // handle enforcement on client tunnels by querying debt keeper
    // this consumes client list
    let start_enforce_benchmark = Instant::now();
    match enforce_exit_clients(reg_clients_list, &rita_exit_cache.debt_actions.clone()) {
        Ok(new_debt_actions) => rita_exit_cache.debt_actions = new_debt_actions,
        Err(e) => warn!("Failed to enforce exit clients with {:?}", e,),
    }
    info!(
        "Finished Rita enforcement in {}ms ",
        start_enforce_benchmark.elapsed().as_millis()
    );
    info!(
        "Finished Rita exit loop in {}ms, all vars should be dropped",
        start.elapsed().as_millis(),
    );

    thread::sleep(EXIT_LOOP_SPEED_DURATION);
    rita_exit_cache
}

fn bill(babel_port: u16, start: Instant, ids: Vec<Identity>, usage_history: ExitLock) {
    trace!("about to try opening babel stream");

    match open_babel_stream(babel_port, EXIT_LOOP_TIMEOUT) {
        Ok(mut stream) => match parse_routes(&mut stream) {
            Ok(routes) => {
                trace!("Sending traffic watcher message?");
                if let Err(e) = watch_exit_traffic(usage_history, &routes, &ids) {
                    error!(
                        "Watch exit traffic failed with {}, in {} millis",
                        e,
                        start.elapsed().as_millis()
                    );
                } else {
                    info!(
                        "Watch exit traffic completed successfully in {} millis",
                        start.elapsed().as_millis()
                    );
                }
            }
            Err(e) => {
                error!(
                    "Watch exit traffic failed with: {} in {} millis",
                    e,
                    start.elapsed().as_millis()
                );
            }
        },
        Err(e) => {
            error!(
                "Watch exit traffic failed with: {} in {} millis",
                e,
                start.elapsed().as_millis()
            );
        }
    }
}

/// Run a region validation and return a list of blacklisted clients. This list is later used
/// in setup clients to teardown blacklisted client tunnels
fn check_regions(start: Instant, clients_list: Vec<Identity>) -> Option<Vec<Identity>> {
    let val = settings::get_rita_exit().allowed_countries.is_empty();
    if !val {
        let res = validate_clients_region(clients_list);
        match res {
            Err(e) => {
                warn!(
                    "Failed to validate client region with {:?} {}ms since start",
                    e,
                    start.elapsed().as_millis()
                );
                return None;
            }
            Ok(blacklist) => {
                info!(
                    "validate client region completed successfully {}ms since loop start",
                    start.elapsed().as_millis()
                );
                return Some(blacklist);
            }
        }
    }
    None
}

fn setup_exit_wg_tunnel() {
    // Setup legacy wg_exit
    if let Err(e) = KI.setup_wg_if_named(LEGACY_INTERFACE) {
        warn!("exit setup returned {}", e)
    }
    // Setup new wg_exit
    if let Err(e) = KI.setup_wg_if_named(EXIT_INTERFACE) {
        warn!("new exit setup returned {}", e)
    }

    let exit_settings = settings::get_rita_exit();

    let local_ip = exit_settings.exit_network.own_internal_ip.into();
    let netmask = exit_settings.exit_network.netmask;
    let mesh_ip = exit_settings
        .network
        .mesh_ip
        .expect("Expected a mesh ip for this exit");
    let enforcement_enabled = exit_settings.exit_network.enable_enforcement;
    let external_v6 = exit_settings
        .exit_network
        .subnet
        .map(|ipv6_subnet| (ipv6_subnet.ip(), ipv6_subnet.prefix()));

    // Setup legacy wg_exit
    KI.one_time_exit_setup(None, None, mesh_ip, LEGACY_INTERFACE, enforcement_enabled)
        .expect("Failed to setup wg_exit!");

    // Setup wg_exit_v2. Local address added is same as that used by wg_exit
    KI.one_time_exit_setup(
        Some((local_ip, netmask)),
        external_v6,
        mesh_ip,
        EXIT_INTERFACE,
        enforcement_enabled,
    )
    .expect("Failed to setup wg_exit_v2!");

    KI.setup_nat(
        &settings::get_rita_exit().network.external_nic.unwrap(),
        LEGACY_INTERFACE,
        None,
    )
    .unwrap();
    KI.setup_nat(
        &settings::get_rita_exit().network.external_nic.unwrap(),
        EXIT_INTERFACE,
        external_v6,
    )
    .unwrap();
}

pub fn start_rita_exit_endpoints(workers: usize) {
    thread::spawn(move || {
        let runner = AsyncSystem::new();
        runner.block_on(async move {
            // Exit stuff, huge threadpool to offset Pgsql blocking
            let _res = HttpServer::new(|| {
                App::new()
                    .route("/secure_setup", web::post().to(secure_setup_request))
                    .route("/secure_status", web::post().to(secure_status_request))
                    .route("/exit_info", web::get().to(get_exit_info_http))
                    .route("/client_debt", web::post().to(get_client_debt))
                    .route("/time", web::get().to(get_exit_timestamp_http))
                    .route("/exit_list", web::post().to(get_exit_list))
                    .route("/exit_list_v2", web::post().to(get_exit_list_v2))
            })
            .workers(workers)
            .bind(format!(
                "[::0]:{}",
                settings::get_rita_exit().exit_network.exit_hello_port
            ))
            .unwrap()
            .shutdown_timeout(0)
            .run()
            .await;
        });
    });
}
